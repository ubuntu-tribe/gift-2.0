GIFT is a gold-indexed ERC-20 that treats **provenance and reserves** as first-class citizens. It couples a conservative, role-locked minting path with a verifiable link to specific vault inventory, then extends that foundation with **on-chain non-fungible gold bars** that map cleanly to real, serialised metal. The result is an instrument that reads well to regulators, feels intuitive to consumers, and gives investors exactly what they want from gold in the digital age: transparency, auditability, and optional delivery without sacrificing the fungibility and liquidity that make ERC-20s useful.

### What the token is

At its core, GIFT is an **upgradeable, pausable** ERC-20 implemented with OpenZeppelin’s UUPS pattern. Governance retains the ability to upgrade logic under strict owner control and to pause transfers in an emergency, but **no one can mint** unless they are the designated **Supply Controller**. In production, the Supply Controller is a dedicated **Minting** contract, not a human key. That Minting contract is itself bound by two independent checks before a single unit can be issued: (1) a **Proof-of-Reserve** (PoR) contract that models the real vaults, and (2) a **Merkle-anchored Registry** that encodes which specific bars/lots (by batch and serial) are allowed to back issuance. Those two gates reserves and provenance form a “two-key” mint path that is simple to reason about and hard to bypass.

### How the Proof-of-Reserve constrains supply

The GIFTPoR contract represents actual vaults and their balances in token units. It assigns **per-minter allowances** against particular vault IDs and tracks each vault’s available balance. When the Supply Controller attempts to mint, it first proves it is an authorised minter, then shows that its allowance for the chosen vault is large enough and that the vault’s balance is sufficient. Only after those checks pass will issuance continue. Immediately following a successful mint, the Minting contract reduces both the minter’s allowance and the vault’s balance so that the on-chain PoR state remains in lockstep with circulating supply. This is deliberately conservative accounting that prevents “paper gold” from drifting away from metal.

### How provenance is tied to actual bars in actual vaults

Reserves alone tell you **how much** exists, not **which** bar you are tied to. That specificity matters for both regulators and owners of gold. The **GIFT Batch Registry** provides it. Before minting can occur, an operator registers a **batch** that commits, by **Merkle root**, to a dataset of authorised mint units (“leaves”). Each leaf is a fixed-format, typed record that includes the Registry address, a `batchId`, a PoR `reserveId`, the authorised **quantity** in token smallest units, the **fine weight in milligrams**, a **serial hash** and other optional origin markers (mine, delivery standard), a **document hash** that anchors the assay and custody dossier, and a small **presence mask** that makes it explicit when a field is intentionally unknown at registration time. The full dataset (CSV/JSON) and proofs are published off-chain and **content-addressed**; the on-chain batch stores only the 32-byte root, the batch cap (the sum of all leaf quantities), and a URI to the dataset.

When the Supply Controller mints, it must present the **leaf fields** for the specific bar/lot and a **Merkle proof**. The Registry recomputes the leaf hash with typed encoding, verifies the proof against the batch root, and then **consumes** part of that leaf’s authorisation by incrementing a per-leaf counter. The Registry refuses to let any leaf or batch be over-consumed. It emits events that make each mint permanently linkable to the relevant batch and serial. Because the Minting contract calls the Registry first and only then calls the ERC-20 `increaseSupply`, a mint cannot succeed unless both provenance and reserves agree.

### The supply lifecycle, end-to-end

In steady state, governance registers a batch that points at a signed dataset for a given vault or lot series. From that point, every issued GIFT unit can be traced back to a **specific Merkle leaf** in that batch. The mint transaction proves inclusion, the Registry records how much of that leaf was consumed, the PoR reduces the vault’s balance and the minter’s allowance, and the ERC-20 supply increases by the same amount. The math is tight: **for each batch, consumed ≤ authorised; for the system, issuance ≤ PoR reserves**. For historic circulation that predates the Registry, a single **legacy acknowledgment** batch is recorded with a reason statement and documentation hash; this makes the accounting exact without retrofitting old bars.

### Non-fungible gold bars on chain, deliverable later

Many holders want the option to take delivery not as an abstraction, but as **specific bars**. On top of GIFT’s fungible layer we expose **on-chain non-fungible gold bars** that can be created later, at the operator’s pace, against those same Merkle leaves. Each certificate is an ERC-721 token that references the exact `(batchId, leaf hash, reserveId, serial hash)` and represents a clear physical unit (for example, **1 kg**, **100 g**, or **1 g** the unit is configurable). The issuance logic enforces a hard cap derived from the leaf’s recorded **fine weight** and, optionally, the **actual amount of ERC-20** that was minted from that leaf. That means you can never create more certificates than the underlying metal allows. For consumers this reads simply: you hold GIFT for liquidity, and when you decide you want **your gold**, you obtain a non-fungible gold bar on chain that maps to a real, serialised bar sitting in the vault. When you request to **redeem your gold**, the platform completes KYC/AML and coordinates with the custodian for collection or delivery. What matters is the experience: it’s gold first, with the chain as the audit trail.

### Why this design is safe

Security here is not a slogan. The GIFT token follows the most widely used library stack in the industry and is **upgradeable** only under owner control. It is **pausable** for incident response. Mint and burn are **role-locked** to a single Supply Controller, and that controller is a contract that itself cannot act unless both the PoR and the Registry allow it. The Registry uses **typed hashing** for leaves (no ambiguous packing), static fields (no dynamic types), and a stable field order (no creative interpretation), making proofs deterministic and verifiable by anyone. The PoR contract keeps reserve math conservative and explicit. Nothing in the mint path depends on untrusted callbacks or exotic opcodes, and each successful step leaves a trail of events that external auditors can replay to reconstruct supply and provenance.

### Why this reads well to regulators

Regulators want to see that issuance is bounded, transparent, and auditable. This system gives them exactly that. The **two-key** mint path means circulating supply cannot exceed a combination of: (i) **vault balances** maintained in the PoR contract; and (ii) **batch and leaf caps** committed by Merkle roots, with the public datasets available for independent verification. Each mint produces on-chain telemetry that ties a quantity to a precise batch and serial; each batch points to an immutable dossier that includes assays, custody attestations, and delivery standards; and each dataset is **content-addressed** so that what is published cannot be silently swapped. Batches are **finalised** when consumed, preventing post-hoc edits. The token is **pausable** in emergencies and **upgradeable** only under governance, preserving safety while allowing controlled evolution. This is the posture asset-referenced token regimes expect.

### Why this delights investors and end users

Investors get the comfort of gold with the flexibility of a modern ledger. GIFT trades and settles like a normal ERC-20, but it is not “just a token” it is a claim whose **backstory is legible**: which vault, which bar standard, which serial. Holders can remain entirely in the fungible world for liquidity, or they can escalate to **on-chain non-fungible gold bars** for specific weights and specific pieces of metal when they want to feel the gravity of the asset. The marketplace that facilitates those certificates is **fully KYC’d**, the vault partners are disclosed, and the redemption process is designed to be as straightforward as ordering delivery: identity verified, paperwork aligned, bar released. It is hard to think of a clearer bridge between markets and metal.

### Implementation details that matter (without the noise)

The GIFT token is an ERC-20 with UUPS upgrades and a global pause. The Minting contract is the **sole** Supply Controller and will not mint until the PoR and Registry both agree. The PoR models vaults, assigns minters to reserves with explicit allowances, and reduces balances as issuance occurs. The Registry accepts batches that commit to datasets by root and keeps a precise ledger of how much of each leaf has been consumed. Leaves are small on purpose **address, ids, quantities, fine weight, serial, origin markers, document hash, timestamp, and a presence mask** and they omit non-essential fields to stay lean and to avoid stack depth issues. Off-chain artifacts live in locations like S3 (with Object Lock) and IPFS; on-chain we store only what is required to verify proofs and to reconcile caps. For historical circulation, a single legacy batch acknowledges the initial three million already issued and links to a documentation bundle.

### The promise

Gold is simple until you digitise it; then simplicity takes work. GIFT embraces that work so that every party regulator, investor, and everyday saver can look at the same chain and see the same story: **there is this much gold in these vaults; this is the exact set of bars that back issuance; this is the precise trail of how supply came to be; and when you decide it’s time, here is the pathway to hold your bar in your own hands.**
